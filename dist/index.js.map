{"version":3,"file":"index.js","sources":["../src/helpers/promise-middleware.ts","../src/helpers/cache.ts","../src/hooks/useApiRequest/index.ts"],"sourcesContent":["export type MiddlewareType<T = any> = (res: T) => void;\n\nexport const setPromiseMiddleware = async (\n  promise: Promise<any>,\n  middleware: MiddlewareType[]\n) => {\n  const result = await promise;\n  for (const middlewareItem of middleware) await middlewareItem(result);\n  return result;\n};\n","interface CacheValue {\n  value: any;\n  date: Date;\n}\n\ninterface StorageService<K = string, T = any> {\n  set: (key: K, value: T) => void;\n  get: (key: K) => T | undefined;\n  delete: (key: K) => void;\n}\n\nconst CACHE_DURATION = 100 * 60 * 60 * 5;\n\nexport const getCacheKey = (name: string, token?: string) => {\n  return name + token;\n};\n\nexport const getCache = (name: string, token?: string): any => {\n  const key = getCacheKey(name, token);\n  return cacheService.get(key);\n};\n\nexport const setCache = (name: string, value: any, token?: string) => {\n  const key = getCacheKey(name, token);\n  return cacheService.set(key, value);\n};\n\nconst LocalStorageService: StorageService<string, CacheValue> = {\n  set: (key: string, value: CacheValue) => {\n    if (!localStorage) return;\n    localStorage.setItem(key, JSON.stringify(value));\n  },\n  get: (key: string) => {\n    if (!localStorage) return undefined;\n    const value = localStorage.getItem(key);\n    if (!value) return undefined;\n    return JSON.parse(value) as CacheValue;\n  },\n  delete: (key: string) => {\n    if (!localStorage) return;\n    localStorage.removeItem(key);\n  }\n};\n\nconst isValidDate = (cacheValueDate: Date) => {\n  const currentDate = new Date();\n  return +currentDate - +new Date(cacheValueDate) <= CACHE_DURATION;\n};\n\nclass CacheService {\n  private cache: StorageService<string, CacheValue>;\n\n  constructor() {\n    this.cache = LocalStorageService;\n  }\n\n  set(key: string, value: any) {\n    const cacheData: CacheValue = {\n      value,\n      date: new Date()\n    };\n    this.cache.set(key, cacheData);\n  }\n\n  get(key: string) {\n    const cacheValue = this.cache.get(key);\n    if (!cacheValue) return undefined;\n    if (!isValidDate(cacheValue.date)) {\n      this.cache.delete(key);\n      return undefined;\n    }\n    return cacheValue.value;\n  }\n}\n\nexport const cacheService = new CacheService();\n","import { useEffect, useState } from \"react\";\nimport { MiddlewareType, setPromiseMiddleware } from \"../../helpers/promise-middleware\";\nimport { getCache, setCache } from '../../helpers/cache';\n\nexport type API_REQUEST_STATUS = \"WAIT\" | \"PENDING\" | \"SUCCESS\" | \"FAIL\";\n\ntype TNullValue = undefined;\nexport const nullValue = undefined;\n\ntype TRequest<T> = Promise<T>;\n\nexport interface TUseApiRequestProps<T = any> {\n  alertService?: IAlertService;\n  getErrorMessageCallback?: (error: any) => string;\n  fetchOnMountData?: any;\n  request: (...args: any) => TRequest<T>;\n  defaultData?: T;\n  catchCallback?: (error: any) => void;\n  successMessage?: string;\n  middleware?: MiddlewareType[];\n  fetchOnMount?: boolean;\n  token?: string;\n  name?: string;\n  cache?: boolean;\n}\n\nexport interface TUseApiRequestOutput<T> {\n  setData: (data: T | TNullValue) => void;\n  status: API_REQUEST_STATUS;\n  errorMessage: string;\n  isPending: boolean;\n  data: T | TNullValue;\n  sendRequest: (props?: any) => TRequest<any>;\n  cleanErrorMessage: () => void;\n}\n\nexport interface IAlert {\n  content: string;\n  title?: string;\n  image?: string;\n  color?: string;\n}\n\nexport interface IAlertService {\n  successAlert: (alert: IAlert) => void;\n  warningAlert: (alert: IAlert) => void;\n  errorAlert: (alert: IAlert) => void;\n}\n\nconst defaultGetErrorMessageCallback = (errorMessage: string) => errorMessage;\n\nconst useApiRequest = <T extends any>({\n                                        token,\n                                        name,\n                                        cache,\n                                        alertService,\n                                        getErrorMessageCallback = defaultGetErrorMessageCallback,\n                                        fetchOnMountData,\n                                        fetchOnMount,\n                                        middleware = [],\n                                        successMessage,\n                                        request,\n                                        defaultData,\n                                        catchCallback\n                                      }: TUseApiRequestProps<T>): TUseApiRequestOutput<T> => {\n  const [status, setStatus] = useState<API_REQUEST_STATUS>(\"WAIT\");\n  const [data, setData] = useState<T | TNullValue>(defaultData || nullValue);\n  const [errorMessage, setErrorMessageState] = useState<string>(\"\");\n  const setErrorMessage = (error: any) =>\n    setErrorMessageState(getErrorMessageCallback(error));\n  const cleanErrorMessage = () => setErrorMessageState(\"\");\n\n  const [isPending, setIsPending] = useState<boolean>(false);\n\n  const sendSuccessMessage = (res: any) => {\n    if (successMessage && alertService)\n      alertService.successAlert({ content: successMessage });\n    setStatus(\"SUCCESS\");\n    return res;\n  };\n\n  const setCacheMiddleware = (res: any) => {\n    if (cache && name) setCache(name, res, token);\n    return res;\n  };\n\n  const middlewareList: MiddlewareType[] = [\n    ...middleware,\n    setCacheMiddleware,\n    setData,\n    cleanErrorMessage,\n    sendSuccessMessage\n  ];\n\n  const sendFetchRequest = (request: TRequest<T>) => {\n    setIsPending(true);\n    setStatus(\"PENDING\");\n    return ((setPromiseMiddleware(\n      request,\n      middlewareList\n    ) as unknown) as Promise<any>)\n      .catch((error: any) => {\n        const errorMessage = getErrorMessageCallback(error);\n        setStatus(\"FAIL\");\n        setErrorMessage(errorMessage);\n        if (alertService) alertService.errorAlert({ content: errorMessage });\n        catchCallback && catchCallback(error);\n      })\n      .finally(() => {\n        setIsPending(false);\n      }) as TRequest<T>;\n  };\n\n  const sendRequest = (props?: any) => {\n    if (cache && name) {\n      const cacheValue = getCache(name, token);\n      if (cacheValue) sendFetchRequest(Promise.resolve(cacheValue));\n    }\n    return sendFetchRequest(request(props));\n  };\n\n  useEffect(() => {\n    if (fetchOnMount) sendRequest(fetchOnMountData);\n  }, []);\n\n  return {\n    setData,\n    status,\n    errorMessage,\n    cleanErrorMessage,\n    isPending,\n    data,\n    sendRequest\n  };\n};\n\nexport default useApiRequest;\n"],"names":["setPromiseMiddleware","promise","middleware","result","_a","middleware_1","_i","middlewareItem","CACHE_DURATION","getCacheKey","name","token","getCache","key","cacheService","get","setCache","value","set","LocalStorageService","localStorage","setItem","JSON","stringify","getItem","parse","delete","removeItem","isValidDate","cacheValueDate","Date","this","cache","CacheService","cacheData","date","cacheValue","nullValue","undefined","defaultGetErrorMessageCallback","errorMessage","useApiRequest","cleanErrorMessage","setErrorMessageState","sendFetchRequest","request","setIsPending","setStatus","middlewareList","catch","error","getErrorMessageCallback","alertService","errorAlert","content","catchCallback","finally","sendRequest","props","Promise","resolve","_b","fetchOnMountData","fetchOnMount","_c","successMessage","defaultData","_d","useState","status","_e","data","setData","_f","_g","isPending","res","successAlert","useEffect"],"mappings":"wwDAEO,IAAMA,qBAAuB,SAClCC,EACAC,yHAEe,SAAMD,UAAfE,EAASC,aACcC,4BAAAC,eAAlBC,QAAmDJ,iBAArBC,iCAAZE,iBAC7B,SAAOH,SCGHK,eAAiB,KAEVC,YAAc,SAACC,EAAcC,GACxC,OAAOD,EAAOC,GAGHC,SAAW,SAACF,EAAcC,GACrC,IAAME,EAAMJ,YAAYC,EAAMC,GAC9B,OAAOG,aAAaC,IAAIF,IAGbG,SAAW,SAACN,EAAcO,EAAYN,GACjD,IAAME,EAAMJ,YAAYC,EAAMC,GAC9B,OAAOG,aAAaI,IAAIL,EAAKI,IAGzBE,oBAA0D,CAC9DD,IAAK,SAACL,EAAaI,GACZG,cACLA,aAAaC,QAAQR,EAAKS,KAAKC,UAAUN,KAE3CF,IAAK,SAACF,GACJ,GAAKO,aAAL,CACA,IAAMH,EAAQG,aAAaI,QAAQX,GACnC,GAAKI,EACL,OAAOK,KAAKG,MAAMR,KAEpBS,OAAQ,SAACb,GACFO,cACLA,aAAaO,WAAWd,KAItBe,YAAc,SAACC,GAEnB,OADoB,IAAIC,KACD,IAAIA,KAAKD,IAAmBrB,wCAMnD,aACEuB,KAAKC,MAAQb,oBAoBjB,OAjBEc,gBAAA,SAAIpB,EAAaI,GACf,IAAMiB,EAAwB,CAC5BjB,QACAkB,KAAM,IAAIL,MAEZC,KAAKC,MAAMd,IAAIL,EAAKqB,IAGtBD,gBAAA,SAAIpB,GACF,IAAMuB,EAAaL,KAAKC,MAAMjB,IAAIF,GAClC,GAAKuB,EAAL,CACA,GAAKR,YAAYQ,EAAWD,MAI5B,OAAOC,EAAWnB,MAHhBc,KAAKC,MAAMN,OAAOb,UAOXC,aAAe,IAAImB,aCpEnBI,eAAYC,EA0CnBC,+BAAiC,SAACC,GAAyB,OAAAA,GAE3DC,cAAgB,SAAgBrC,GAmBV,SAApBsC,IAA0B,OAAAC,EAAqB,IAwB5B,SAAnBC,EAAoBC,GAGxB,OAFAC,GAAa,GACbC,EAAU,WACD/C,qBACP6C,EACAG,GAECC,MAAM,SAACC,GACN,IAAMV,EAAeW,EAAwBD,GAC7CH,EAAU,QAlCdJ,EAAqBQ,EAmCDX,IACZY,GAAcA,EAAaC,WAAW,CAAEC,QAASd,IACrDe,GAAiBA,EAAcL,KAEhCM,QAAQ,WACPV,GAAa,KAIC,SAAdW,EAAeC,GACnB,IACQtB,EAGR,OAJIJ,GAAStB,KACL0B,EAAaxB,SAASF,EAAMC,KAClBiC,EAAiBe,QAAQC,QAAQxB,KAE5CQ,EAAiBC,EAAQa,QAlEI/C,UACAD,SACAsB,UACAoB,iBACAS,4BAAAV,aAA0BZ,iCAC1BuB,qBACAC,iBACAC,eAAA9D,aAAa,KACb+D,mBACApB,YACAqB,gBACAX,kBAEhCY,EAAsBC,eAA6B,QAAlDC,OAAQtB,OACTuB,EAAkBF,eAAyBF,GAAe7B,WAAzDkC,OAAMC,OACPC,EAAuCL,eAAiB,IAAvD5B,OAAcG,OAKf+B,EAA4BN,gBAAkB,GAA7CO,OAAW7B,OAcZE,iBACD9C,GANsB,SAAC0E,GAE1B,OADI5C,GAAStB,GAAMM,SAASN,EAAMkE,EAAKjE,GAChCiE,GAMPJ,EACA9B,EAhByB,SAACkC,GAI1B,OAHIX,GAAkBb,GACpBA,EAAayB,aAAa,CAAEvB,QAASW,IACvClB,EAAU,WACH6B,KA+CT,OAJAE,gBAAU,WACJf,GAAcN,EAAYK,IAC7B,IAEI,CACLU,UACAH,SACA7B,eACAE,oBACAiC,YACAJ,OACAd"}